## Java 关键字汇总

### 常见的关键字

```
用于定义数据类型的关键字
class interface    byte short int long float double char boolean void               
用于定义数据类型值的关键字
true false null       
用于定义流程控制的关键字
if    else switch    case default while do for break    continue return           
用于定义访问权限修饰符的关键字
private    protected public       
用于定义类，函数，变量修饰符的关键字
abstract final static synchronized   
用于定义类与类之间关系的关键字
extends    implements           
用于定义建立实例及引用实例，判断实例的关键字
new    this super instanceof   
用于异常处理的关键字
try    catch finally throw    throws
用于包的关键字
package    import           
其他修饰符关键字
native strictfp transient volatile assert
```



### 关键字的作用说明

```
break           用在 switch 或者循环语句中，表示中断结束的意思，跳出循环直接可以结束该语句
continue        用在循环语句中，表示中断结束的意思，不过跟 break 有区别，它是退出本次循环后继续执行下一次循环           
return          常用功能是结束一个方法（退出一个方法），跳转到上层调用的方法
interface       接口的意思，用来定义接口。
static          静态修饰符，被修饰后成员被该类所有的对象所共有。也可以通过类名调用
private         权限修饰符，可以修饰成员变量和成员方法，被修饰的成员只能在本类中被访问        隐藏具体实现细节，提供对外公共访问方法，提高安全性
this            当成员变量和局部变量名称一样时，需要用 this 修饰，谁调用这个方法,那么该方法的内部的this就代表谁，如果不适用 this ，那么局部变量隐藏了成员变量
super           代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)
final           由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final
                可以修饰类，变量，成员方法。被修饰类不能被继承；被修饰的方法不能被重写；被修饰的变量不能被重新赋值,因为这个量其实是一个常量。
                修饰基本数据类型    指的是值不能被改变；修饰引用数据类型    指的是地址值不能被改变
finally         被finally控制的语句体一定会执行；特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))
                finally的作用:    用于释放资源，在IO流操作和数据库操作中会见到
abstract        抽象的意思，用来修饰抽象类与抽象方法
                abstract 不能和哪些关键字共存?
                    private    冲突        被private修饰的方法不能被子类继承,就不能被重写,而我们的抽象方法还需要被子类重写
                    final      冲突        被final修饰的方法,不能被子类重写 , ,而我们的抽象方法还需要被子类重写
                    static     无意义    因为被static修饰的方法可以通过类名直接访问,但是我们的抽象方法没有方法体,所以这样访问没有意思
extends         继承的意思，通过它可以类与类之间产生继承关系。
implements      实现的意思，通过它可以让类与接口之间产生实现关系。
instanceof      测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据
```



### 重要关键字说明

#### 3.1 instanceof

- 它的作用是什么？

  - instanceof是Java的一个二元操作符，和==，>，<是同一类东西。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据。

- 使用过程中注意事项有哪些？

  - 类的实例包含本身的实例，以及所有直接或间接子类的实例
  - instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误

  ```
  //比如下面就会编译错误
  String s = null;
  s instanceof null
  s instanceof Integer
  ```

#### 3.2 this和super

- 面向对象之this关键字
  - 为什么要有this
    - 当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题
  - this关键字特点
    - 是当前类的对象引用
    - 简单的记，它就代表当前类的一个对象。谁调用这个方法,那么该方法的内部的this就代表谁
  - this的应用场景
    - 解决局部变量隐藏成员变量
- this和super的区别
  - A:通过问题引出super
    - 子类局部范围访问父类成员变量
  - B:说说this和super的区别
    - this 代表的是本类对象的引用
    - super 代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)
  - C:this和super的使用
    - a:调用成员变量
      - this.成员变量 调用本类的成员变量
      - super.成员变量 调用父类的成员变量
    - b:调用构造方法
      - this(...) 调用本类的构造方法
      - super(...) 调用父类的构造方法
    - c:调用成员方法
      - this.成员方法 调用本类的成员方法
      - super.成员方法 调用父类的成员方法



###   二进制

- **进制有哪些**
- 二进制
  - 0和1 前缀0B或者0b 比如：0B1001 转为十进制是9
- 八进制
  - 0-7 前缀0 比如：0103
- 十进制【我们常用的】
  - 0-9 没有前缀
- 十六进制
  - 0-9 和 A-F 前缀0x或者0X 比如：0x123
- 进制转化
  - 任何进制转化为十进制公式：系数 * 底数 ^ 指数

```
0b1010 = 1 * 2^3 + 0 *2^2 + 1*2^1 + 0*2^0
       = 8 + 0 + 2 + 0
       = 10

0123  = 1*8^2 + 2*8^1 + 3*8^0
      = 64 + 16 + 3
      = 83

0x123 = 1*16^2 + 2*16^1 + 3*16^0
      = 256 + 32 + 3
      = 291
```

- 3.2 补码
  - 正数的补码和原码相同

```
5
原码：0000 0101
补码：0000 0101
	* 负数的补码是它的反码加1

-5：
原码：1000 0101
反码：1111 1010
    +         1
------------------
补码  1111 1011
```



### Java的内存分配以及栈和堆的区别

10.1 先了解几个概念

- 栈
- 堆
- 方法区
- 本地方法去
- 寄存器

```
A:栈: 存放的是局部变量
局部变量：在方法定义或者方法声明上的变量都是局部变量。
B:堆: 存放的是所有new出来的东西
特点：
    a: 每一个new出来的东西都会为其分配一个地制值。
    b: 每一个变量都有一个默认的值
        byte，short，int，long  -- 0
        float，double            -- 0.0
        char                    -- '\u0000'
        boolean                -- false
        引用数据类型               -- null       
    c: 使用完毕就变成了垃圾，等待垃圾回收器对其回收
C:方法区:(面向对象部分讲解)
D:本地方法区:(和系统相关)
E:寄存器:(cpu使用)
```

### 使用switch和if-else区别

- **11.1 switch语句特点**
  - 使用switch语句时，要注意表达式必须是符合byte，char，short，int或枚举类型的表达式，而不能使用浮点类型或long类型。
  - switch语句将表达式的值依次与每个case子语句中的常量值相比较。如果匹配成功，则执行该case语句中的语句，直到遇到break语句为止。
  - default语句是可选的，当表达式的值与任何一个case语句都不匹配时，就执行default后的语句。
- **11.2 switch语句与if-else比较**
  - if-else只是单纯地一个接一个比较；if...else每个条件都计算一遍；
  - 使用了Binary，Tree算法；绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true。编译器编译switch与编译if...else...不同。不管有多少case，都直接跳转，不需逐个比较查询；switch只计算一次值，然后都是test , jmp……有很多else if的时候，用switch case比较清晰
  - switch...case与if...else，if的根本区别在于，switch...case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch...case不用像if...else那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。





### 基本类型有哪些

- Java定义了八种基本数据类型：

  byte，short，int，long，char，float，double，boolean

  。

  - 基本数据类型也称为简单类型，这些类型可以分为四组：
    - 1.整型。包括byte，short，int，long。用于表示有符号整数。
    - 2.浮点型。包括float，double。用于表示带小数位的数字。
    - 3.字符型。包括char。用于表示字符集中的符号。
    - 4.布尔型。包括boolean。用于表示true/false值。
  - 开发者可以直接使用这些类型，也可以使用它们来构造数组以及自定义类型。因此，它们形成了所有可以创建的其他类型的基础。Java在其他方面是完全面向对象的，但基本数据类型并不是面向对象的，这样设计的原因是为了效率。将基本数据类型设计为对象会极大地降低性能。
  - 因为Java语言的特色之一就是具备可移植性，即不管在哪个平台下运行，一份代码无需修改就可以直接运行。为了确保这一点，基本数据类型被定义为具有明确的范围和数学行为，与C和C++这类语言“允许整数的大小随着执行环境的要求而变化”不同，Java语言的数据类型都具有严格定义的范围。无论在那种平台下，int总是32位的。虽然严格指定基本数据类型的范围在某些环境下会造成性能损失，但这是为了实现可移植性而必须付出的。

- Java的八种基本类型说明如下所示，其中每一种都有特定的格式和大小

  | 基本类型 | 说明                   | 字节数  |
  | -------- | ---------------------- | ------- |
  | byte     | 字节长度的整数，八位   | 1个字节 |
  | short    | 短整数，十六位         | 2个字节 |
  | int      | 整数，三十二位         | 4个字节 |
  | long     | 长整数，六十四位       | 8个字节 |
  | float    | 单精度浮点数，三十二位 | 4个字节 |
  | double   | 双精度浮点数，六十四位 | 8个字节 |
  | char     | Unicode字符            | 2个字节 |
  | boolean  | 布尔值                 | 1个字节 |





### 关于int和Integer的问题区别分析



- 1.1 编译阶段、运行时，自动装箱 / 自动拆箱是发生在什么阶段？
- 1.2使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？
- 1.3为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？
- 1.4 阅读过 Integer 源码吗？分析下类或某些方法的设计要点？
- 1.5 int和Integer的区别

```
1、Integer是int的包装类，int则是java的一种基本数据类型 
2、Integer变量必须实例化后才能使用，而int变量不需要 
3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 
4、Integer的默认值是null，int的默认值是0

延伸： 
关于Integer和int的比较 
1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。

Integer i = new Integer(100);
Integer j = new Integer(100);
System.out.print(i == j); //false

2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）

Integer i = new Integer(100);
int j = 100；
System.out.print(i == j); //true

3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）

Integer i = new Integer(100);
Integer j = 100;
System.out.print(i == j); //false

4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false

Integer i = 100;
Integer j = 100;
System.out.print(i == j); //true

Integer i = 128;
Integer j = 128;
System.out.print(i == j); //false

对于第4条的原因： 
java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：

public static Integer valueOf(int i){
    assert IntegerCache.high >= 127;
    if (i >= IntegerCache.low && i <= IntegerCache.high){
        return IntegerCache.cache[i + (-IntegerCache.low)];
    }
    return new Integer(i);
}

java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了
```



### **static深入理解**

#### static的作用和特点



- 可以用来修饰：成员变量，成员方法，代码块，内部类等。具体如下所示
  - 修饰成员变量和成员方法
    - 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。
    - 被static 声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。
  - 静态代码块
    - 静态代码块定义在类中方法外,静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)
    - 该类不管创建多少对象，静态代码块只执行一次.
  - **静态内部类（static修饰类的话只能修饰内部类）**
  - 静态内部类与非静态内部类之间存在一个最大的区别:
    - 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：1.它的创建是不需要依赖外围类的创建。2.它不能使用任何外围类的非static成员变量和方法。
  - 静态导包(用来导入类中的静态资源，1.5之后的新特性):
    - 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。
- static关键字的特点
  - 随着类的加载而加载
  - 优先于对象存在
  - 被类的所有对象共享
  - 可以通过类名调用【静态修饰的内容一般我们称其为：与类相关的，类成员】
- static的注意事项
  - 在静态方法中是没有this关键字的
    - 静态是随着类的加载而加载，this是随着对象的创建而存在。
    - 静态比对象先存在。
  - 静态方法只能访问静态的成员变量和静态的成员方法【静态只能访问静态,非静态可以访问静态的也可以访问非静态的】



#### static变量存储位置

static变量存储位置

- 注意是：存储在JVM的方法区中
- static变量在类加载时被初始化，存储在JVM的方法区中，整个内存中只有一个static变量的拷贝，可以使用类名直接访问，也可以通过类的实例化对象访问，一般不推荐通过实例化对象访问，通俗的讲static变量属于类，不属于对象，任何实例化的对象访问的都是同一个static变量，任何地放都可以通过类名来访问static变量。





#### 用static静态变量潜在性问题

用static静态变量潜在性问题

- 1.占用内存，并且内存一般不会释放；
- 2.在系统不够内存情况下会自动回收静态内存，这样就会引起访问全局静态错误。
- 3.在Android中不能将activity作为static静态对象，这样使activity的所有组件对象都存入全局内存中，并且不会被回收；



#### 静态引用的对象回收



静态引用的对象回收

- 只要静态变量没有被销毁也没有置null，其对象一直被保持引用，也即引用计数不可能是0，因此不会被垃圾回收。因此，单例对象在运行时不会被回收



#### 静态变量和成员变量的区别

- A:所属不同
  - 静态变量属于类，所以也称为类变量
  - 成员变量属于对象，所以也称为实例变量(对象变量)
- B:内存中位置不同
  - 静态变量存储于方法区的静态区
  - 成员变量存储于堆内存
- C:内存出现时间不同
  - 静态变量随着类的加载而加载，随着类的消失而消失
  - 成员变量随着对象的创建而存在，随着对象的消失而消失
- D:调用不同
  - 静态变量可以通过类名调用，也可以通过对象调用
  - 成员变量只能通过对象名调用































