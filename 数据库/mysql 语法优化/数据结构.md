group by 会使用临时表 增加I/O操作，降低查询效率


反范式化：为了查询效率的考虑，把原本符合第三范式的表适当增加冗余，
          以达到优化查询效率的目的。以空间换取时间的操作

反范式化：就是做的事情和范式化是反着来的，目的也很简单，以空间换时间、简化编程的复杂度，
          实际的效果就是编写的SQL语句更加的简单了，并且对应的SQL语句的执行效率也更加的高了！



表的垂直拆分的原则
所谓垂直拆分，就是把原来一个有很多列的表拆分成多个表解决表的宽度问题，通常拆分原则如下：
1、把不常用的字段单独存放到一个表中
2、把大字段独立存放到一个表中
3、把经常一起使用的字段放到一起



垂直拆分:一个表的列太多,可以分为多个表..
水平拆分:一个表中的数据太多,分多表结构不变
为了解决单表数据量过大的问题，每个水平拆分表的结构完全一致

方法
1.对id进行hash运算，可以取mod
2.针对不同的hashId把数据放到不同的表中

水平拆分之后的挑战
1.跨分区进行数据查询
2。统计及后台报表操作

前后台使用的表进行分开，前台要求查询效率，所以可以说会用拆分之后的表，后台在统计数据时可以使用汇总表。



表的范式化即数据库设计的规范化：数据表不存在非关键字段对任意关键字段的传递函数依赖，则符合第三范式。
可以将一张数据表进行拆分，来满足第三范式的要求。
设计表的时候符合范式化是为了：减少数据冗余、减少表的插入、更新、删除异常
设计表的时候使用反范式化是为了：以空间换时间、增强代码的可编程性和可维护性
不符合第三范式要求的表存在以下问题：
1.数据冗余:（分类、分类描述）对于每一个商品都会进行记录
2.数据插入异常
3.数据更新异常
4.数据删除异常

选择合适的数据类型
1.使用可存下数据的最小的数据类型
2.使用简单地数据类型，Int要比varchar类型在mysql处理上更简单
3.尽可能使用not null定义字段，这是由innodb的特性决定的，
    因为非not null的数据可能需要一些额外的字段进行存储，这样就会增加一些IO。
    可以对非null的字段设置一个默认值
4.尽量少用text，非用不可最好分表，
  将text字段存放到另一张表中，在需要的时候再使用联合查询，这样可提高查询主表的效率
例子1、用Int存储日期时间
from_unixtime()可将Int类型的时间戳转换为时间格式
select from_unixtime(1392178320); 输出为 2014-02-12 12:12:00
unix_timestamp()可将时间格式转换为Int类型
select unix_timestamp('2014-02-12 12:12:00'); 输出为1392178320
例子2
存储IP地址——bigInt
利用inet_aton(),inet_ntoa()转换
select inet_aton('192.169.1.1'); 输出为3232301313
select inet_ntoa(3232301313); 输出为192.169.1.1



数据库优良设计：
A、减少数据冗余
B、避免数据维护异常
C、节约存储空间
D、高效的访问

数据库设计：简单的讲就是一个应用系统需要存放数据，我们需要思考用几个表来实现，我们需要建库建表，
        建表是最为关键的，我们需要思考建几张表，表与表之间的关系是什么，每张表有多少字段，
        特别是联系表与表之间关系的字段尤其要设计好，每个字段有什么特性，
        比如：数据类型、数据长度、数据约束（主外键、唯一约束、非空约束等）、数据索引等

*************************************************************************************
数据库设计的步骤：
A、需求分析（数据分析）
B、逻辑设计（ER图）
C、物理设计（数据库特点转换）
D、维护优化（需求建表、索引优化，大表拆分）

*************************************************************************************
数据库设计
就是建库、建表，建库是比较容易的，建表是相对复杂的，关系型数据，表结构就是根本，
所以这一步最为关键也最为复杂，建表不好的地方在于，建立表之间的关系是复杂的，
建立表之间的关系的复杂体现在实现表与表之间联系的字段的选择上。
这一步如果搞定之后，下面就是每个表中的字段类型、长度、约束的建立，这些东西，关系到程序是否好写，存储是否方便，查询是否高效。


1，对一个数据库设计前，我们要了解我们数据库要存入哪些数据，这些数据有哪些特征(重要程度？ 时效性？ )然后对症下药，
    时效性不同->可以定时归档，清理。   重要程度或扩展程度不同可以->分库分表……
2，了解数据之间的联系，1对1,1对多还是多对多，从而建立的数据表可以是独立的，可以是关联性质的。
3，如果是日志文件，我们打算存入数据库。就要想到这种数据增长性很大，如果只存不清理会造成数据库使用量的大幅度增长，是不好的。
    我们要定期进行归档，清除操作。
*************************************************************************************
1，我们接到一个项目：
首先要去分析这个项目有哪些模块--->然后针对具体模块分析有哪些属性--->针对属性分析哪个属性或哪几个属性的集合可以用来标识这个属性[唯一标识]------->分析这个模块数据是否永久存储，
    是否数据增长很快，是否经常查询---->如果是就要考虑分库分表了。
    如果不是，那么这些数据是否只会存储一定时间，是否需要永久记录--->如果是我们就定期归档及数据的迁移操作了。
如：注册用户表：
属性：用户名，密码，电话，邮箱，地址，昵称，头像，……
唯一标识： 邮箱？ 用户名+邮箱->md5加密来标识？……
存储特点：随系统上线时间逐渐增加，需要永久存储。 ---> 必须分库分表操作了。
如拟定2亿用户 可以分4个库，每个库100张表，每张表50w条记录。

2，分析这些模块之间的关联性：
1对1？ 1对多？ 多对多？ ---->画ER图。

比如，电子商务网站系统包括几个模块：用户模块，商品模块，订单模块，购物车模块，供应商模块。
记录注册用户信息
属性：用户名、密码、电话、邮箱、身份证号、地址、姓名、昵称。。。
可选唯一标识属性：用户名、身份证号、电话
存储特点：随系统上线时间逐渐增加，需要永久存储。
